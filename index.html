<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sudoku Web Game</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-soft: #1f2937;
      --line: #3b4255;
      --line-strong: #6b7280;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --primary: #22c55e;
      --primary-soft: #14532d;
      --danger: #ef4444;
      --danger-soft: #7f1d1d;
      --hint: #38bdf8;
      --cell-size: clamp(34px, 8.8vw, 58px);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 15% 10%, #1e293b 0%, transparent 30%),
        radial-gradient(circle at 85% 80%, #172554 0%, transparent 25%),
        var(--bg);
      color: var(--text);
      font-family: Inter, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      padding: 24px 12px;
    }

    .app {
      width: min(680px, 100%);
      background: color-mix(in srgb, var(--panel) 92%, black 8%);
      border: 1px solid #263043;
      border-radius: 16px;
      padding: 20px;
      box-shadow:
        0 12px 36px rgba(0, 0, 0, 0.45),
        inset 0 1px 0 rgba(255, 255, 255, 0.04);
      display: grid;
      gap: 16px;
    }

    .title-wrap h1 {
      font-size: clamp(24px, 4vw, 32px);
      letter-spacing: 0.4px;
    }

    .title-wrap p {
      margin-top: 4px;
      color: var(--muted);
      font-size: 14px;
    }

    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    label {
      font-size: 14px;
      color: var(--muted);
    }

    select,
    button {
      border-radius: 10px;
      border: 1px solid #374151;
      background: var(--panel-soft);
      color: var(--text);
      font-size: 14px;
      line-height: 1;
      padding: 10px 12px;
      cursor: pointer;
      transition: 140ms ease;
    }

    select {
      padding-right: 30px;
      margin-left: 6px;
      outline: none;
    }

    button:hover,
    select:hover {
      border-color: #4b5563;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    button.primary {
      background: #14532d;
      border-color: #166534;
    }

    button.warn {
      background: #3f1c1c;
      border-color: #7f1d1d;
    }

    .status {
      background: #0b1220;
      border: 1px solid #1f2b3f;
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 6px;
    }

    .status-top {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: center;
      color: var(--muted);
      font-size: 14px;
    }

    #message {
      min-height: 20px;
      font-size: 14px;
      color: #cbd5e1;
    }

    #message[data-tone="success"] {
      color: #86efac;
    }

    #message[data-tone="error"] {
      color: #fca5a5;
    }

    #message[data-tone="info"] {
      color: #7dd3fc;
    }

    .board-wrap {
      display: grid;
      place-content: center;
      overflow-x: auto;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(9, var(--cell-size));
      grid-template-rows: repeat(9, var(--cell-size));
      border: 2px solid var(--line-strong);
      border-radius: 8px;
      overflow: hidden;
      background: #0b1220;
      user-select: none;
    }

    .cell {
      border: 1px solid var(--line);
      background: #111827;
      color: #dbeafe;
      font-size: clamp(18px, 3.6vw, 28px);
      font-weight: 600;
      display: grid;
      place-items: center;
      padding: 0;
      width: var(--cell-size);
      height: var(--cell-size);
      border-radius: 0;
    }

    .cell:hover {
      background: #172036;
      transform: none;
      border-color: #4b5563;
    }

    .cell.fixed {
      color: #f9fafb;
      background: #1f2937;
      cursor: default;
    }

    .cell.empty {
      color: transparent;
    }

    .cell.selected {
      background: #1d4ed8;
      color: #fff;
      box-shadow: inset 0 0 0 1px #93c5fd;
    }

    .cell.related {
      background: #1e293b;
    }

    .cell.same-value {
      background: #10243a;
      color: #93c5fd;
    }

    .cell.hinted {
      color: #7dd3fc;
    }

    .cell.error {
      background: #7f1d1d;
      color: #fee2e2;
    }

    .box-top {
      border-top-width: 2px;
      border-top-color: var(--line-strong);
    }

    .box-left {
      border-left-width: 2px;
      border-left-color: var(--line-strong);
    }

    .box-right {
      border-right-width: 2px;
      border-right-color: var(--line-strong);
    }

    .box-bottom {
      border-bottom-width: 2px;
      border-bottom-color: var(--line-strong);
    }

    .number-pad {
      display: grid;
      grid-template-columns: repeat(5, minmax(48px, 1fr));
      gap: 8px;
    }

    .number-pad button {
      padding: 12px 0;
      font-size: 18px;
      font-weight: 600;
      border-radius: 10px;
    }

    .number-pad button[data-value="0"] {
      grid-column: span 2;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.2px;
    }

    .hint {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    @media (max-width: 560px) {
      .app {
        padding: 14px;
      }

      .controls button,
      .controls select {
        padding: 9px 10px;
      }
    }
  </style>
</head>
<body>
  <main class="app" aria-label="Sudoku game">
    <header class="title-wrap">
      <h1>Sudoku</h1>
      <p>Play directly in your browser with keyboard and number pad support.</p>
    </header>

    <section class="controls">
      <label for="difficulty">Difficulty:</label>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
      <button id="newGame" class="primary">New Game</button>
      <button id="resetBoard">Reset</button>
      <button id="checkBoard">Check</button>
      <button id="hintCell">Hint</button>
      <button id="solveBoard" class="warn">Solve</button>
    </section>

    <section class="status" aria-live="polite">
      <div class="status-top">
        <span>Time: <strong id="timer">00:00</strong></span>
        <span>Mistakes: <strong id="mistakes">0/3</strong></span>
      </div>
      <p id="message" data-tone="info">Choose a difficulty and start.</p>
    </section>

    <section class="board-wrap">
      <div id="board" class="board" role="grid" aria-label="9 by 9 Sudoku board"></div>
    </section>

    <section class="number-pad" id="numberPad" aria-label="Number pad">
      <button type="button" data-value="1">1</button>
      <button type="button" data-value="2">2</button>
      <button type="button" data-value="3">3</button>
      <button type="button" data-value="4">4</button>
      <button type="button" data-value="5">5</button>
      <button type="button" data-value="6">6</button>
      <button type="button" data-value="7">7</button>
      <button type="button" data-value="8">8</button>
      <button type="button" data-value="9">9</button>
      <button type="button" data-value="0">Clear Cell</button>
    </section>

    <p class="hint">
      Controls: click a cell then type 1-9, Backspace/Delete to clear, Arrow keys to move.
      Three mistakes ends the round.
    </p>
  </main>

  <script>
    const BOARD_SIZE = 9;
    const SUBGRID_SIZE = 3;
    const CELL_COUNT = BOARD_SIZE * BOARD_SIZE;
    const MAX_MISTAKES = 3;

    const DIFFICULTIES = {
      easy: { label: "Easy", removals: 40 },
      medium: { label: "Medium", removals: 48 },
      hard: { label: "Hard", removals: 54 },
    };

    const boardElement = document.getElementById("board");
    const difficultySelect = document.getElementById("difficulty");
    const timerElement = document.getElementById("timer");
    const mistakesElement = document.getElementById("mistakes");
    const messageElement = document.getElementById("message");
    const numberPad = document.getElementById("numberPad");

    const cellElements = [];

    const state = {
      initialPuzzle: [],
      board: [],
      solution: [],
      fixedCells: new Set(),
      hintedCells: new Set(),
      errorCells: new Set(),
      selectedIndex: null,
      mistakes: 0,
      elapsedSeconds: 0,
      timerId: null,
      status: "idle",
    };

    function toIndex(row, col) {
      return row * BOARD_SIZE + col;
    }

    function indexToRow(index) {
      return Math.floor(index / BOARD_SIZE);
    }

    function indexToCol(index) {
      return index % BOARD_SIZE;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function getCandidates(board, index) {
      if (board[index] !== 0) return [];

      const row = indexToRow(index);
      const col = indexToCol(index);
      const used = new Set();

      for (let c = 0; c < BOARD_SIZE; c += 1) {
        const rowValue = board[toIndex(row, c)];
        if (rowValue !== 0) used.add(rowValue);
      }

      for (let r = 0; r < BOARD_SIZE; r += 1) {
        const colValue = board[toIndex(r, col)];
        if (colValue !== 0) used.add(colValue);
      }

      const boxRow = Math.floor(row / SUBGRID_SIZE) * SUBGRID_SIZE;
      const boxCol = Math.floor(col / SUBGRID_SIZE) * SUBGRID_SIZE;
      for (let r = boxRow; r < boxRow + SUBGRID_SIZE; r += 1) {
        for (let c = boxCol; c < boxCol + SUBGRID_SIZE; c += 1) {
          const boxValue = board[toIndex(r, c)];
          if (boxValue !== 0) used.add(boxValue);
        }
      }

      const candidates = [];
      for (let value = 1; value <= 9; value += 1) {
        if (!used.has(value)) candidates.push(value);
      }
      return candidates;
    }

    function findBestCell(board) {
      let bestIndex = -1;
      let bestCandidates = null;

      for (let index = 0; index < CELL_COUNT; index += 1) {
        if (board[index] !== 0) continue;
        const candidates = getCandidates(board, index);
        if (candidates.length === 0) return { index, candidates };
        if (bestIndex === -1 || candidates.length < bestCandidates.length) {
          bestIndex = index;
          bestCandidates = candidates;
          if (candidates.length === 1) break;
        }
      }

      if (bestIndex === -1) return { index: -1, candidates: [] };
      return { index: bestIndex, candidates: bestCandidates };
    }

    function solveBoard(board, randomize = false) {
      const { index, candidates } = findBestCell(board);
      if (index === -1) return true;
      if (candidates.length === 0) return false;

      const choices = randomize ? shuffle([...candidates]) : candidates;
      for (const value of choices) {
        board[index] = value;
        if (solveBoard(board, randomize)) return true;
      }
      board[index] = 0;
      return false;
    }

    function countSolutions(board, limit = 2) {
      let solutionCount = 0;

      function search() {
        if (solutionCount >= limit) return;
        const { index, candidates } = findBestCell(board);
        if (index === -1) {
          solutionCount += 1;
          return;
        }
        if (candidates.length === 0) return;

        for (const value of candidates) {
          board[index] = value;
          search();
          if (solutionCount >= limit) break;
        }
        board[index] = 0;
      }

      search();
      return solutionCount;
    }

    function generateSolvedBoard() {
      const solved = Array(CELL_COUNT).fill(0);
      solveBoard(solved, true);
      return solved;
    }

    function generatePuzzle(difficultyKey) {
      const targetRemovals = DIFFICULTIES[difficultyKey].removals;
      let bestResult = null;

      for (let attempt = 0; attempt < 6; attempt += 1) {
        const solution = generateSolvedBoard();
        const puzzle = [...solution];
        const positions = shuffle(Array.from({ length: CELL_COUNT }, (_, i) => i));
        let removed = 0;

        for (const index of positions) {
          if (removed >= targetRemovals) break;
          const backup = puzzle[index];
          puzzle[index] = 0;

          const testBoard = [...puzzle];
          const count = countSolutions(testBoard, 2);
          if (count !== 1) {
            puzzle[index] = backup;
            continue;
          }
          removed += 1;
        }

        if (!bestResult || removed > bestResult.removed) {
          bestResult = {
            puzzle: [...puzzle],
            solution: [...solution],
            removed,
          };
        }

        if (removed >= targetRemovals) break;
      }

      return bestResult;
    }

    function formatTime(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    }

    function updateStatusBar() {
      timerElement.textContent = formatTime(state.elapsedSeconds);
      mistakesElement.textContent = `${state.mistakes}/${MAX_MISTAKES}`;
    }

    function setMessage(text, tone = "info") {
      messageElement.textContent = text;
      messageElement.dataset.tone = tone;
    }

    function startTimer() {
      stopTimer();
      state.timerId = window.setInterval(() => {
        if (state.status !== "playing") return;
        state.elapsedSeconds += 1;
        updateStatusBar();
      }, 1000);
    }

    function stopTimer() {
      if (state.timerId) {
        window.clearInterval(state.timerId);
        state.timerId = null;
      }
    }

    function createBoardUI() {
      boardElement.innerHTML = "";
      cellElements.length = 0;

      for (let index = 0; index < CELL_COUNT; index += 1) {
        const row = indexToRow(index);
        const col = indexToCol(index);

        const cell = document.createElement("button");
        cell.type = "button";
        cell.className = "cell";
        cell.setAttribute("role", "gridcell");
        cell.setAttribute("aria-label", `Row ${row + 1} Column ${col + 1}`);
        cell.dataset.index = String(index);

        if (row % 3 === 0) cell.classList.add("box-top");
        if ((row + 1) % 3 === 0) cell.classList.add("box-bottom");
        if (col % 3 === 0) cell.classList.add("box-left");
        if ((col + 1) % 3 === 0) cell.classList.add("box-right");

        cell.addEventListener("click", () => {
          state.selectedIndex = index;
          renderBoard();
        });

        cellElements.push(cell);
        boardElement.appendChild(cell);
      }
    }

    function isRelated(index, selectedIndex) {
      if (selectedIndex === null || index === selectedIndex) return false;
      const row = indexToRow(index);
      const col = indexToCol(index);
      const selectedRow = indexToRow(selectedIndex);
      const selectedCol = indexToCol(selectedIndex);

      const sameRow = row === selectedRow;
      const sameCol = col === selectedCol;
      const sameBox =
        Math.floor(row / 3) === Math.floor(selectedRow / 3) &&
        Math.floor(col / 3) === Math.floor(selectedCol / 3);

      return sameRow || sameCol || sameBox;
    }

    function renderBoard() {
      const selectedIndex = state.selectedIndex;
      const selectedValue = selectedIndex === null ? 0 : state.board[selectedIndex];

      for (let index = 0; index < CELL_COUNT; index += 1) {
        const cell = cellElements[index];
        const value = state.board[index];
        const isFixed = state.fixedCells.has(index);

        cell.textContent = value === 0 ? "" : String(value);
        cell.classList.toggle("empty", value === 0);
        cell.classList.toggle("fixed", isFixed);
        cell.classList.toggle("selected", index === selectedIndex);
        cell.classList.toggle("related", isRelated(index, selectedIndex));
        cell.classList.toggle("same-value", selectedValue !== 0 && value === selectedValue && index !== selectedIndex);
        cell.classList.toggle("hinted", state.hintedCells.has(index));
        cell.classList.toggle("error", state.errorCells.has(index));
      }

      updateStatusBar();
    }

    function firstEditableIndex() {
      for (let index = 0; index < CELL_COUNT; index += 1) {
        if (!state.fixedCells.has(index)) return index;
      }
      return null;
    }

    function isSolved() {
      return state.board.every((value, index) => value === state.solution[index]);
    }

    function loseGame() {
      state.status = "lost";
      stopTimer();
      setMessage("Game over: no attempts left. Use Solve or start a new game.", "error");
      renderBoard();
    }

    function winGame() {
      state.status = "won";
      stopTimer();
      setMessage(`Solved in ${formatTime(state.elapsedSeconds)}. Great job!`, "success");
      renderBoard();
    }

    function clearCell(index) {
      if (index === null || state.status !== "playing" || state.fixedCells.has(index)) return;
      state.board[index] = 0;
      state.hintedCells.delete(index);
      state.errorCells.delete(index);
      renderBoard();
    }

    function placeValue(index, value) {
      if (index === null || state.status !== "playing" || state.fixedCells.has(index)) return;
      if (value < 1 || value > 9) return;

      state.board[index] = value;
      state.hintedCells.delete(index);

      if (value !== state.solution[index]) {
        state.mistakes += 1;
        state.errorCells.add(index);
        renderBoard();

        const lockedValue = value;
        window.setTimeout(() => {
          if (state.board[index] === lockedValue) {
            state.board[index] = 0;
          }
          state.errorCells.delete(index);
          renderBoard();
        }, 450);

        if (state.mistakes >= MAX_MISTAKES) {
          loseGame();
        } else {
          setMessage(`Incorrect value. Remaining attempts: ${MAX_MISTAKES - state.mistakes}.`, "error");
        }
        renderBoard();
        return;
      }

      state.errorCells.delete(index);
      if (isSolved()) {
        winGame();
      } else {
        setMessage("Good move.", "success");
        renderBoard();
      }
    }

    function moveSelection(rowOffset, colOffset) {
      if (state.selectedIndex === null) return;
      const currentRow = indexToRow(state.selectedIndex);
      const currentCol = indexToCol(state.selectedIndex);
      const nextRow = (currentRow + rowOffset + BOARD_SIZE) % BOARD_SIZE;
      const nextCol = (currentCol + colOffset + BOARD_SIZE) % BOARD_SIZE;
      state.selectedIndex = toIndex(nextRow, nextCol);
      renderBoard();
    }

    function highlightWrongCells(indices) {
      for (const index of indices) state.errorCells.add(index);
      renderBoard();
      window.setTimeout(() => {
        for (const index of indices) state.errorCells.delete(index);
        renderBoard();
      }, 700);
    }

    function checkCurrentBoard() {
      if (state.status !== "playing") return;

      const wrongIndices = [];
      for (let index = 0; index < CELL_COUNT; index += 1) {
        const value = state.board[index];
        if (value !== 0 && value !== state.solution[index]) wrongIndices.push(index);
      }

      if (wrongIndices.length > 0) {
        highlightWrongCells(wrongIndices);
        setMessage(`${wrongIndices.length} incorrect cell(s) highlighted.`, "error");
        return;
      }

      if (state.board.includes(0)) {
        setMessage("No incorrect values found so far.", "info");
        return;
      }

      winGame();
    }

    function hintOneCell() {
      if (state.status !== "playing") return;

      let target = null;
      if (
        state.selectedIndex !== null &&
        !state.fixedCells.has(state.selectedIndex) &&
        state.board[state.selectedIndex] === 0
      ) {
        target = state.selectedIndex;
      } else {
        const empties = [];
        for (let index = 0; index < CELL_COUNT; index += 1) {
          if (!state.fixedCells.has(index) && state.board[index] === 0) {
            empties.push(index);
          }
        }
        if (empties.length === 0) {
          setMessage("No empty cells left for a hint.", "info");
          return;
        }
        target = empties[Math.floor(Math.random() * empties.length)];
      }

      state.board[target] = state.solution[target];
      state.hintedCells.add(target);
      state.errorCells.delete(target);
      state.selectedIndex = target;

      if (isSolved()) {
        winGame();
      } else {
        setMessage("Hint applied to one cell.", "info");
        renderBoard();
      }
    }

    function solveCurrentPuzzle() {
      if (state.solution.length === 0) return;
      state.board = [...state.solution];
      state.status = "solved";
      stopTimer();
      state.selectedIndex = null;
      state.errorCells.clear();
      setMessage("Solution revealed. Start a new game for another puzzle.", "info");
      renderBoard();
    }

    function resetCurrentPuzzle() {
      if (state.initialPuzzle.length === 0) return;
      state.board = [...state.initialPuzzle];
      state.hintedCells.clear();
      state.errorCells.clear();
      state.mistakes = 0;
      state.elapsedSeconds = 0;
      state.status = "playing";
      state.selectedIndex = firstEditableIndex();
      setMessage("Board reset.", "info");
      startTimer();
      renderBoard();
    }

    function startNewGame() {
      stopTimer();
      setMessage("Generating puzzle...", "info");

      window.setTimeout(() => {
        const difficultyKey = difficultySelect.value;
        const generated = generatePuzzle(difficultyKey);

        state.initialPuzzle = [...generated.puzzle];
        state.board = [...generated.puzzle];
        state.solution = [...generated.solution];
        state.fixedCells = new Set();
        state.hintedCells.clear();
        state.errorCells.clear();
        state.mistakes = 0;
        state.elapsedSeconds = 0;
        state.status = "playing";

        for (let index = 0; index < CELL_COUNT; index += 1) {
          if (state.initialPuzzle[index] !== 0) state.fixedCells.add(index);
        }

        state.selectedIndex = firstEditableIndex();
        startTimer();
        setMessage(
          `${DIFFICULTIES[difficultyKey].label} puzzle ready. Fill all cells without exceeding 3 mistakes.`,
          "info"
        );
        renderBoard();
      }, 30);
    }

    function handleKeyboardInput(event) {
      if (state.selectedIndex === null) return;

      if (event.key >= "1" && event.key <= "9") {
        event.preventDefault();
        placeValue(state.selectedIndex, Number(event.key));
        return;
      }

      switch (event.key) {
        case "Backspace":
        case "Delete":
        case "0":
          event.preventDefault();
          clearCell(state.selectedIndex);
          break;
        case "ArrowUp":
          event.preventDefault();
          moveSelection(-1, 0);
          break;
        case "ArrowDown":
          event.preventDefault();
          moveSelection(1, 0);
          break;
        case "ArrowLeft":
          event.preventDefault();
          moveSelection(0, -1);
          break;
        case "ArrowRight":
          event.preventDefault();
          moveSelection(0, 1);
          break;
        default:
          break;
      }
    }

    function handlePadInput(event) {
      const target = event.target.closest("button[data-value]");
      if (!target) return;
      if (state.selectedIndex === null) return;

      const value = Number(target.dataset.value);
      if (value === 0) {
        clearCell(state.selectedIndex);
      } else {
        placeValue(state.selectedIndex, value);
      }
    }

    document.getElementById("newGame").addEventListener("click", startNewGame);
    document.getElementById("resetBoard").addEventListener("click", resetCurrentPuzzle);
    document.getElementById("checkBoard").addEventListener("click", checkCurrentBoard);
    document.getElementById("hintCell").addEventListener("click", hintOneCell);
    document.getElementById("solveBoard").addEventListener("click", solveCurrentPuzzle);
    numberPad.addEventListener("click", handlePadInput);
    document.addEventListener("keydown", handleKeyboardInput);

    createBoardUI();
    startNewGame();
  </script>
</body>
</html>

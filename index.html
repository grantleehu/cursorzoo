<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sudoku Web Game</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background:
        radial-gradient(circle at 20% 20%, #1d4ed8 0%, transparent 42%),
        radial-gradient(circle at 85% 12%, #4f46e5 0%, transparent 40%),
        linear-gradient(165deg, #0f172a 0%, #1f2937 100%);
      color: #e5e7eb;
      padding: 20px;
    }

    .app {
      width: min(700px, 96vw);
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 16px;
      box-shadow: 0 25px 60px rgba(0, 0, 0, 0.38);
      backdrop-filter: blur(8px);
      padding: 18px 18px 22px;
    }

    h1 {
      margin: 0;
      text-align: center;
      font-size: clamp(1.35rem, 2.6vw, 2rem);
      letter-spacing: 0.5px;
    }

    .subtitle {
      margin: 8px 0 14px;
      text-align: center;
      color: #cbd5e1;
      font-size: 0.95rem;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }

    button,
    select {
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 0.92rem;
      font-weight: 600;
      background: rgba(30, 41, 59, 0.92);
      color: #e2e8f0;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.12s ease, border-color 0.12s ease;
    }

    button:hover,
    select:hover {
      border-color: #93c5fd;
      background: rgba(30, 64, 175, 0.9);
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled,
    select:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(70px, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }

    .stat {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 10px;
      text-align: center;
    }

    .stat-label {
      display: block;
      color: #cbd5e1;
      font-size: 0.78rem;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.05rem;
      font-weight: 700;
      color: #f8fafc;
    }

    .status {
      margin: 10px 0 14px;
      min-height: 24px;
      text-align: center;
      color: #bfdbfe;
      font-weight: 600;
    }

    .status.error {
      color: #fecaca;
    }

    .status.success {
      color: #bbf7d0;
    }

    .board {
      width: min(560px, 92vw);
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(9, minmax(0, 1fr));
      aspect-ratio: 1 / 1;
      border: 3px solid #334155;
      border-radius: 8px;
      overflow: hidden;
      background: #0f172a;
    }

    .board.solved {
      border-color: #16a34a;
      box-shadow: 0 0 0 2px rgba(22, 163, 74, 0.35);
    }

    .cell {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: 1px solid #64748b;
      font-size: clamp(0.95rem, 2.2vw, 1.35rem);
      font-weight: 700;
      text-align: center;
      color: #f8fafc;
      background: #111827;
      outline: none;
      caret-color: transparent;
      transition: background 0.12s ease, color 0.12s ease, box-shadow 0.12s ease;
    }

    .cell.thick-right {
      border-right-width: 3px;
      border-right-color: #334155;
    }

    .cell.thick-bottom {
      border-bottom-width: 3px;
      border-bottom-color: #334155;
    }

    .cell.clue {
      color: #93c5fd;
      background: #1e293b;
    }

    .cell.peer {
      background: #1f2937;
    }

    .cell.same-value {
      background: #243f67;
    }

    .cell.selected {
      background: #1d4ed8;
      color: #ffffff;
      box-shadow: inset 0 0 0 2px #bfdbfe;
    }

    .cell.incorrect {
      background: #7f1d1d;
      color: #fee2e2;
    }

    .cell.hinted {
      color: #86efac;
    }

    .numpad {
      width: min(560px, 92vw);
      margin: 14px auto 0;
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
    }

    .numpad button {
      padding: 10px 0;
      font-size: 1rem;
    }

    .footer-note {
      margin: 12px 0 0;
      text-align: center;
      color: #94a3b8;
      font-size: 0.82rem;
    }

    @media (max-width: 520px) {
      .app {
        padding: 14px 12px 16px;
      }

      .controls {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .stats {
        grid-template-columns: 1fr;
      }

      .numpad {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>Sudoku Web Game</h1>
    <p class="subtitle">Fill each row, column, and 3x3 box with digits 1-9.</p>

    <section class="controls">
      <select id="difficultySelect" aria-label="Choose difficulty">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
      <button id="newGameBtn" type="button">New Game</button>
      <button id="resetBtn" type="button">Reset</button>
      <button id="checkBtn" type="button">Check</button>
      <button id="hintBtn" type="button">Hint</button>
      <button id="solveBtn" type="button">Solve</button>
    </section>

    <section class="stats">
      <div class="stat">
        <span class="stat-label">Time</span>
        <span class="stat-value" id="timerValue">00:00</span>
      </div>
      <div class="stat">
        <span class="stat-label">Mistakes</span>
        <span class="stat-value" id="mistakeValue">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Best</span>
        <span class="stat-value" id="bestValue">--:--</span>
      </div>
    </section>

    <p class="status" id="statusMessage" role="status" aria-live="polite">Generating puzzle...</p>

    <div class="board" id="board" aria-label="Sudoku board"></div>
    <section class="numpad" id="numpad" aria-label="Number pad"></section>

    <p class="footer-note">Tip: You can also use keyboard numbers and arrow keys.</p>
  </main>

  <script>
    const SIZE = 9;
    const BOX_SIZE = 3;
    const DIGITS = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    const REMOVALS_BY_DIFFICULTY = {
      easy: 38,
      medium: 46,
      hard: 52,
    };
    const BEST_TIME_STORAGE_KEY = "sudokuBestTimeByDifficulty";

    const boardEl = document.getElementById("board");
    const numpadEl = document.getElementById("numpad");
    const timerValueEl = document.getElementById("timerValue");
    const mistakeValueEl = document.getElementById("mistakeValue");
    const bestValueEl = document.getElementById("bestValue");
    const statusMessageEl = document.getElementById("statusMessage");
    const difficultySelectEl = document.getElementById("difficultySelect");

    const newGameBtn = document.getElementById("newGameBtn");
    const resetBtn = document.getElementById("resetBtn");
    const checkBtn = document.getElementById("checkBtn");
    const hintBtn = document.getElementById("hintBtn");
    const solveBtn = document.getElementById("solveBtn");

    let solutionBoard = [];
    let initialBoard = [];
    let currentBoard = [];
    let cellElements = [];
    let selectedCell = null;
    let hintedCells = new Set();

    let mistakes = 0;
    let gameFinished = false;
    let elapsedSeconds = 0;
    let timerId = null;

    let bestTimes = {};

    function createEmptyBoard() {
      return Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    }

    function cloneBoard(board) {
      return board.map((row) => row.slice());
    }

    function shuffle(values) {
      const arr = values.slice();
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const randomIndex = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];
      }
      return arr;
    }

    function getCandidates(board, row, col) {
      const used = new Set();
      for (let i = 0; i < SIZE; i += 1) {
        used.add(board[row][i]);
        used.add(board[i][col]);
      }
      const boxRowStart = Math.floor(row / BOX_SIZE) * BOX_SIZE;
      const boxColStart = Math.floor(col / BOX_SIZE) * BOX_SIZE;
      for (let r = boxRowStart; r < boxRowStart + BOX_SIZE; r += 1) {
        for (let c = boxColStart; c < boxColStart + BOX_SIZE; c += 1) {
          used.add(board[r][c]);
        }
      }
      return DIGITS.filter((digit) => !used.has(digit));
    }

    function findBestEmptyCell(board) {
      let best = null;
      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          if (board[row][col] !== 0) {
            continue;
          }
          const candidates = getCandidates(board, row, col);
          if (candidates.length === 0) {
            return { row, col, candidates };
          }
          if (!best || candidates.length < best.candidates.length) {
            best = { row, col, candidates };
            if (candidates.length === 1) {
              return best;
            }
          }
        }
      }
      return best;
    }

    function solveBoard(board) {
      const spot = findBestEmptyCell(board);
      if (!spot) {
        return true;
      }
      if (spot.candidates.length === 0) {
        return false;
      }
      const candidates = shuffle(spot.candidates);
      for (const candidate of candidates) {
        board[spot.row][spot.col] = candidate;
        if (solveBoard(board)) {
          return true;
        }
      }
      board[spot.row][spot.col] = 0;
      return false;
    }

    function countSolutions(board, limit = 2) {
      let count = 0;
      function search() {
        if (count >= limit) {
          return;
        }
        const spot = findBestEmptyCell(board);
        if (!spot) {
          count += 1;
          return;
        }
        if (spot.candidates.length === 0) {
          return;
        }
        for (const candidate of spot.candidates) {
          board[spot.row][spot.col] = candidate;
          search();
          if (count >= limit) {
            break;
          }
        }
        board[spot.row][spot.col] = 0;
      }
      search();
      return count;
    }

    function fillBox(board, startRow, startCol) {
      const values = shuffle(DIGITS);
      let index = 0;
      for (let row = startRow; row < startRow + BOX_SIZE; row += 1) {
        for (let col = startCol; col < startCol + BOX_SIZE; col += 1) {
          board[row][col] = values[index];
          index += 1;
        }
      }
    }

    function generateSolvedBoard() {
      const board = createEmptyBoard();
      fillBox(board, 0, 0);
      fillBox(board, 3, 3);
      fillBox(board, 6, 6);
      solveBoard(board);
      return board;
    }

    function createPuzzleFromSolution(solution, removals) {
      const puzzle = cloneBoard(solution);
      const positions = shuffle(Array.from({ length: SIZE * SIZE }, (_, index) => index));
      let removedCount = 0;
      for (const position of positions) {
        if (removedCount >= removals) {
          break;
        }
        const row = Math.floor(position / SIZE);
        const col = position % SIZE;
        const backup = puzzle[row][col];
        puzzle[row][col] = 0;

        const candidateBoard = cloneBoard(puzzle);
        const solutions = countSolutions(candidateBoard, 2);
        if (solutions === 1) {
          removedCount += 1;
        } else {
          puzzle[row][col] = backup;
        }
      }
      return { puzzle, removedCount };
    }

    function parseBestTimes() {
      try {
        const raw = localStorage.getItem(BEST_TIME_STORAGE_KEY);
        return raw ? JSON.parse(raw) : {};
      } catch (error) {
        return {};
      }
    }

    function saveBestTimes() {
      localStorage.setItem(BEST_TIME_STORAGE_KEY, JSON.stringify(bestTimes));
    }

    function formatTime(totalSeconds) {
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
      const seconds = String(totalSeconds % 60).padStart(2, "0");
      return `${minutes}:${seconds}`;
    }

    function setStatus(message, type = "info") {
      statusMessageEl.textContent = message;
      statusMessageEl.classList.remove("error", "success");
      if (type === "error") {
        statusMessageEl.classList.add("error");
      } else if (type === "success") {
        statusMessageEl.classList.add("success");
      }
    }

    function updateMistakeDisplay() {
      mistakeValueEl.textContent = String(mistakes);
    }

    function updateBestDisplay() {
      const difficulty = difficultySelectEl.value;
      const best = bestTimes[difficulty];
      bestValueEl.textContent = typeof best === "number" ? formatTime(best) : "--:--";
    }

    function startTimer() {
      stopTimer();
      elapsedSeconds = 0;
      timerValueEl.textContent = formatTime(elapsedSeconds);
      timerId = window.setInterval(() => {
        elapsedSeconds += 1;
        timerValueEl.textContent = formatTime(elapsedSeconds);
      }, 1000);
    }

    function stopTimer() {
      if (timerId !== null) {
        clearInterval(timerId);
        timerId = null;
      }
    }

    function sameBox(rowA, colA, rowB, colB) {
      return (
        Math.floor(rowA / BOX_SIZE) === Math.floor(rowB / BOX_SIZE)
        && Math.floor(colA / BOX_SIZE) === Math.floor(colB / BOX_SIZE)
      );
    }

    function getCellKey(row, col) {
      return `${row}-${col}`;
    }

    function isEditable(row, col) {
      return initialBoard[row][col] === 0 && !gameFinished;
    }

    function clearInteractiveClasses() {
      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          const cell = cellElements[row][col];
          cell.classList.remove("selected", "peer", "same-value");
        }
      }
    }

    function highlightSelection() {
      clearInteractiveClasses();
      if (!selectedCell) {
        return;
      }
      const { row, col } = selectedCell;
      const selectedValue = currentBoard[row][col];
      for (let r = 0; r < SIZE; r += 1) {
        for (let c = 0; c < SIZE; c += 1) {
          const cell = cellElements[r][c];
          if (r === row || c === col || sameBox(r, c, row, col)) {
            cell.classList.add("peer");
          }
          if (selectedValue !== 0 && currentBoard[r][c] === selectedValue) {
            cell.classList.add("same-value");
          }
        }
      }
      cellElements[row][col].classList.add("selected");
    }

    function updateSingleCell(row, col) {
      const cell = cellElements[row][col];
      const value = currentBoard[row][col];
      const isClue = initialBoard[row][col] !== 0;
      const key = getCellKey(row, col);

      cell.value = value === 0 ? "" : String(value);
      cell.classList.toggle("clue", isClue);
      cell.classList.toggle("hinted", hintedCells.has(key));
      cell.classList.toggle("incorrect", value !== 0 && value !== solutionBoard[row][col]);
      cell.readOnly = isClue || gameFinished;
    }

    function refreshBoard() {
      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          updateSingleCell(row, col);
        }
      }
      highlightSelection();
    }

    function buildBoard() {
      boardEl.innerHTML = "";
      cellElements = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          const cell = document.createElement("input");
          cell.type = "text";
          cell.className = "cell";
          cell.maxLength = 1;
          cell.inputMode = "numeric";
          cell.autocomplete = "off";
          cell.spellcheck = false;
          cell.setAttribute("aria-label", `Row ${row + 1} Column ${col + 1}`);

          if ((col + 1) % BOX_SIZE === 0 && col !== SIZE - 1) {
            cell.classList.add("thick-right");
          }
          if ((row + 1) % BOX_SIZE === 0 && row !== SIZE - 1) {
            cell.classList.add("thick-bottom");
          }

          cell.addEventListener("focus", () => {
            selectedCell = { row, col };
            highlightSelection();
          });

          cell.addEventListener("click", () => {
            selectedCell = { row, col };
            highlightSelection();
          });

          cell.addEventListener("input", () => {
            if (!isEditable(row, col)) {
              updateSingleCell(row, col);
              return;
            }
            const clean = cell.value.replace(/[^1-9]/g, "").slice(-1);
            const value = clean === "" ? 0 : Number(clean);
            cell.value = clean;
            applyPlayerMove(row, col, value);
          });

          cell.addEventListener("keydown", (event) => {
            if (event.key.startsWith("Arrow")) {
              event.preventDefault();
              handleArrowNavigation(event.key);
              return;
            }

            if (!isEditable(row, col)) {
              return;
            }

            if (/^[1-9]$/.test(event.key)) {
              event.preventDefault();
              applyPlayerMove(row, col, Number(event.key));
              return;
            }

            if (event.key === "Backspace" || event.key === "Delete" || event.key === "0") {
              event.preventDefault();
              applyPlayerMove(row, col, 0);
            }
          });

          cellElements[row][col] = cell;
          boardEl.appendChild(cell);
        }
      }
    }

    function handleArrowNavigation(key) {
      if (!selectedCell) {
        selectedCell = { row: 0, col: 0 };
      }
      const deltas = {
        ArrowUp: [-1, 0],
        ArrowDown: [1, 0],
        ArrowLeft: [0, -1],
        ArrowRight: [0, 1],
      };
      const [deltaRow, deltaCol] = deltas[key];
      let nextRow = (selectedCell.row + deltaRow + SIZE) % SIZE;
      let nextCol = (selectedCell.col + deltaCol + SIZE) % SIZE;
      selectedCell = { row: nextRow, col: nextCol };
      cellElements[nextRow][nextCol].focus();
      highlightSelection();
    }

    function isPuzzleSolved() {
      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          if (currentBoard[row][col] !== solutionBoard[row][col]) {
            return false;
          }
        }
      }
      return true;
    }

    function finishGame(mode) {
      if (gameFinished) {
        return;
      }
      gameFinished = true;
      stopTimer();
      boardEl.classList.add("solved");
      refreshBoard();

      if (mode === "player") {
        const difficulty = difficultySelectEl.value;
        const previousBest = bestTimes[difficulty];
        if (typeof previousBest !== "number" || elapsedSeconds < previousBest) {
          bestTimes[difficulty] = elapsedSeconds;
          saveBestTimes();
          updateBestDisplay();
          setStatus(`Solved in ${formatTime(elapsedSeconds)}. New best time!`, "success");
        } else {
          setStatus(`Solved in ${formatTime(elapsedSeconds)}. Great job!`, "success");
        }
      } else {
        setStatus("Puzzle solved automatically.", "success");
      }
    }

    function applyPlayerMove(row, col, value) {
      if (!isEditable(row, col)) {
        return;
      }
      const previousValue = currentBoard[row][col];
      currentBoard[row][col] = value;
      hintedCells.delete(getCellKey(row, col));
      updateSingleCell(row, col);
      highlightSelection();

      if (value === 0) {
        setStatus("Cell cleared.");
        return;
      }

      if (value !== solutionBoard[row][col] && value !== previousValue) {
        mistakes += 1;
        updateMistakeDisplay();
        setStatus("That number is incorrect.", "error");
      } else if (value === solutionBoard[row][col]) {
        setStatus("Good move.");
      }

      if (isPuzzleSolved()) {
        finishGame("player");
      }
    }

    function resetGame() {
      if (!initialBoard.length) {
        return;
      }
      hintedCells = new Set();
      currentBoard = cloneBoard(initialBoard);
      mistakes = 0;
      gameFinished = false;
      selectedCell = null;
      boardEl.classList.remove("solved");
      updateMistakeDisplay();
      startTimer();
      refreshBoard();
      setStatus("Board reset.");
    }

    function checkBoard() {
      if (gameFinished) {
        return;
      }
      let incorrect = 0;
      let empty = 0;
      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          const value = currentBoard[row][col];
          if (value === 0) {
            empty += 1;
          } else if (value !== solutionBoard[row][col]) {
            incorrect += 1;
          }
          updateSingleCell(row, col);
        }
      }
      highlightSelection();
      if (incorrect === 0 && empty === 0) {
        finishGame("player");
        return;
      }
      setStatus(`Check result: ${incorrect} incorrect, ${empty} empty.`, incorrect > 0 ? "error" : "info");
    }

    function giveHint() {
      if (gameFinished) {
        return;
      }
      const candidates = [];
      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          if (initialBoard[row][col] === 0 && currentBoard[row][col] !== solutionBoard[row][col]) {
            candidates.push({ row, col });
          }
        }
      }

      if (candidates.length === 0) {
        setStatus("No hint needed. Board is already correct.", "success");
        return;
      }

      const pick = candidates[Math.floor(Math.random() * candidates.length)];
      const { row, col } = pick;
      currentBoard[row][col] = solutionBoard[row][col];
      hintedCells.add(getCellKey(row, col));
      selectedCell = { row, col };
      updateSingleCell(row, col);
      highlightSelection();
      cellElements[row][col].focus();
      setStatus("Hint revealed.");

      if (isPuzzleSolved()) {
        finishGame("player");
      }
    }

    function solvePuzzle() {
      if (!solutionBoard.length) {
        return;
      }
      currentBoard = cloneBoard(solutionBoard);
      hintedCells = new Set();
      for (let row = 0; row < SIZE; row += 1) {
        for (let col = 0; col < SIZE; col += 1) {
          updateSingleCell(row, col);
        }
      }
      highlightSelection();
      finishGame("auto");
    }

    function setControlsDisabled(disabled) {
      difficultySelectEl.disabled = disabled;
      newGameBtn.disabled = disabled;
      resetBtn.disabled = disabled;
      checkBtn.disabled = disabled;
      hintBtn.disabled = disabled;
      solveBtn.disabled = disabled;
    }

    function generateNewPuzzle() {
      setControlsDisabled(true);
      stopTimer();
      setStatus("Generating puzzle...");
      boardEl.classList.remove("solved");

      window.setTimeout(() => {
        try {
          const difficulty = difficultySelectEl.value;
          const removeCount = REMOVALS_BY_DIFFICULTY[difficulty];

          solutionBoard = generateSolvedBoard();
          const { puzzle, removedCount } = createPuzzleFromSolution(solutionBoard, removeCount);
          initialBoard = puzzle;
          currentBoard = cloneBoard(initialBoard);
          hintedCells = new Set();
          selectedCell = null;
          mistakes = 0;
          gameFinished = false;

          updateMistakeDisplay();
          updateBestDisplay();
          refreshBoard();
          startTimer();

          const summary = removedCount < removeCount
            ? `New ${difficulty} puzzle ready (removed ${removedCount} cells).`
            : `New ${difficulty} puzzle ready.`;
          setStatus(summary, "success");
        } catch (error) {
          setStatus("Failed to generate puzzle. Please try again.", "error");
        } finally {
          setControlsDisabled(false);
        }
      }, 25);
    }

    function buildNumpad() {
      numpadEl.innerHTML = "";
      for (let value = 1; value <= 9; value += 1) {
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = String(value);
        button.addEventListener("click", () => {
          if (!selectedCell) {
            setStatus("Select a cell first.");
            return;
          }
          applyPlayerMove(selectedCell.row, selectedCell.col, value);
        });
        numpadEl.appendChild(button);
      }
      const clearButton = document.createElement("button");
      clearButton.type = "button";
      clearButton.textContent = "Clear";
      clearButton.addEventListener("click", () => {
        if (!selectedCell) {
          setStatus("Select a cell first.");
          return;
        }
        applyPlayerMove(selectedCell.row, selectedCell.col, 0);
      });
      numpadEl.appendChild(clearButton);
    }

    function registerEvents() {
      newGameBtn.addEventListener("click", generateNewPuzzle);
      resetBtn.addEventListener("click", resetGame);
      checkBtn.addEventListener("click", checkBoard);
      hintBtn.addEventListener("click", giveHint);
      solveBtn.addEventListener("click", solvePuzzle);
      difficultySelectEl.addEventListener("change", updateBestDisplay);
    }

    function init() {
      bestTimes = parseBestTimes();
      buildBoard();
      buildNumpad();
      registerEvents();
      updateBestDisplay();
      generateNewPuzzle();
    }

    init();
  </script>
</body>
</html>
